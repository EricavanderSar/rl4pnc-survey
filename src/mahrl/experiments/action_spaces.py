"""
Implements the codes to configure the three kinds of action spaces.
"""

import json
import os.path
from collections import Counter
from typing import List
from tqdm import tqdm

import grid2op
import numpy as np
import pandas as pd
from grid2op.Action import BaseAction
from grid2op.Environment import BaseEnv, MultiEnvMultiProcess

from mahrl.grid2op_env.utils import get_possible_topologies


def get_changeable_substations_tennet(env: BaseEnv) -> list[int]:
    """
    Find all substations that have more than four lines and can therefore be acted upon
    according to the proposed TenneT action space.
    """
    changeable_substations = []

    # for all substations
    nr_substations = len(env.sub_info)
    for sub in range(nr_substations):
        nr_elements = len(env.observation_space.get_obj_substations(substation_id=sub))
        nr_non_lines = sum(
            1
            for row in env.observation_space.get_obj_substations(substation_id=sub)
            if row[1] != -1 or row[2] != -1
        )
        nr_lines = nr_elements - nr_non_lines

        # append this substation if it has more than four lines
        if nr_lines >= 4:
            changeable_substations.append(sub)

    return changeable_substations


def get_action_space(env: BaseEnv,
                     act_space_name: str,
                     incl_dn: bool = False,
                     adjust_shunt: str = "",
                     rho_filter: float = 2.0,
                     workers: int = 8) -> list[BaseAction]:
    """
        This returns all actions as generated by get_possible_topologies().
    """
    print(f'Initialize "{act_space_name}" action space with dn={incl_dn}...')
    changeable_substations = get_changeable_substations_tennet(env) if act_space_name.startswith('tennet') else list(
        range(len(env.sub_info)))

    # Generic part
    legal_actions = []
    # all substations
    possible_substation_actions = get_possible_topologies(
        env, changeable_substations
    )

    if not incl_dn:
        # Create the DataFrame with defined columns
        dataframe = pd.DataFrame(
            columns=list(
                range(len(possible_substation_actions[0].to_json()["_set_topo_vect"]))
            )
        )

    if act_space_name == 'tennet':
        non_lines = np.concatenate(
            (env.action_space.gen_pos_topo_vect, env.action_space.load_pos_topo_vect)
        ).tolist()

    for action in possible_substation_actions:
        topo_vect = action.set_bus
        if act_space_name == 'medha' or act_space_name == 'tennet':
            if act_space_name =='medha':
                # Select elements for this substation
                sub_elements = [num for num in topo_vect if num != 0]
            if act_space_name == 'tennet':
                # Select line elements for this substation
                lines_topo_vect = np.delete(topo_vect, non_lines)
                # Filter out non-zero elements
                sub_elements = [num for num in lines_topo_vect if num != 0]

            # Count occurrences of each non-zero element
            element_counts = Counter(sub_elements)

            # Check if there are at least two occurrences of each non-zero element
            at_least_two_occurrences = all(count >= 2 for count in element_counts.values())

            if incl_dn:
                if at_least_two_occurrences:
                    legal_actions.append(action)
            else:
                # get_possible_topologies already takes into account that a generator connected to no
                # substation-substation lines does not work, so the constraint to check if one
                # substation-substation line is connected to each busbar does not need to be tested
                if at_least_two_occurrences:
                    dataframe.loc[len(dataframe.index)] = topo_vect
                else:  # add dummy to keep index intact
                    dataframe.loc[len(dataframe.index)] = [0] * env.dim_topo
        else:
            # include all actions, no filtering applied.
            dataframe.loc[len(dataframe.index)] = topo_vect

    if incl_dn:
        # add do nothing actions of subs with only 1 line:
        count_lines = Counter(env.line_ex_to_subid) + Counter(env.line_or_to_subid)
        one_line_subs = [sub for sub, n_lines in count_lines.items() if n_lines == 1]
        for sub in one_line_subs:
            # Default DN topology
            topo = np.ones(env.sub_info[sub], dtype=int)
            action = env.action_space(
                {"set_bus": {"substations_id": [(sub, topo)]}}
            )
            legal_actions.append(action)
    else:
        for index, row in dataframe.iterrows():
            # Identify positive entries in the current row
            positive_entries = row[row > 0].index.tolist()

            # Check if the positive entries in the current row have corresponding empty columns in other rows
            # in other words check if there exists another action next to this one (otherwise it is the DN action)
            meets_condition = all(
                dataframe.loc[dataframe.index != index, positive_entries].eq(0).all(axis=1)
            )

            if not meets_condition:
                legal_actions.append(possible_substation_actions[index])

    if adjust_shunt == "opt":
        legal_actions = get_optshunt_actions(env, legal_actions)
    elif adjust_shunt == "all":
        legal_actions = get_optshunt_actions(env, legal_actions)
    if rho_filter < 2.0:
        legal_actions = apply_rho_filter(env, legal_actions, rho_filter, workers)

    return legal_actions

# def get_asymmetrical_action_space(env: BaseEnv) -> list[BaseAction]:
#     """
#     This returns all actions as generated by get_possible_topologies().
#     """
#     legal_actions = []
#     # all substations
#     possible_substation_actions = get_possible_topologies(
#         env, list(range(len(env.sub_info)))
#     )
#
#     # Create the DataFrame with defined columns
#     dataframe = pd.DataFrame(
#         columns=list(
#             range(len(possible_substation_actions[0].to_json()["_set_topo_vect"]))
#         )
#     )
#
#     for action in possible_substation_actions:
#         topo_vect = action.to_json()["_set_topo_vect"]
#         dataframe.loc[len(dataframe.index)] = topo_vect
#
#     for index, row in dataframe.iterrows():
#         # Identify positive entries in the current row
#         positive_entries = row[row > 0].index.tolist()
#
#         # Check if the positive entries in the current row have corresponding empty columns in other rows
#         meets_condition = all(
#             dataframe.loc[dataframe.index != index, positive_entries].eq(0).all(axis=1)
#         )
#
#         if not meets_condition:
#             legal_actions.append(possible_substation_actions[index])
#
#     return legal_actions
#
#
# def get_medha_action_space(env: BaseEnv, incl_dn: bool = False, opt_shunt: bool = False, all_shunt: bool = False, rho_filter: bool = False) -> list[BaseAction]:
#     """
#     Generate allowed actions based on the proposed action space by Subramanian et al. (2021).
#     """
#
#     # look at all substations (since all substations have more than one element)
#     possible_substation_actions = get_possible_topologies(
#         env, list(range(env.n_sub))
#     )
#
#     legal_actions = []
#
#     # Create the DataFrame with defined columns
#     dataframe = pd.DataFrame(
#         columns=list(
#             range(len(possible_substation_actions[0].to_json()["_set_topo_vect"]))
#         )
#     )
#
#     for action in possible_substation_actions:
#         topo_vect = action.set_bus
#         # Isolate this substation
#         non_zero_elements = [num for num in topo_vect if num != 0]
#
#         # Count occurrences of each non-zero element
#         element_counts = Counter(non_zero_elements)
#
#         # Check if there are at least two occurrences of each non-zero element
#         at_least_two_occurrences = all(count >= 2 for count in element_counts.values())
#
#         if incl_dn:
#             if at_least_two_occurrences:
#                 legal_actions.append(action)
#         else:
#             # get_possible_topologies already takes into account that a generator connected to no
#             # substation-substation lines does not work, so the constraint to check if one
#             # substation-substation line is connected to each busbar does not need to be tested
#             if at_least_two_occurrences:
#                 dataframe.loc[len(dataframe.index)] = topo_vect
#             else:  # add dummy to keep index intact
#                 dataframe.loc[len(dataframe.index)] = [0] * env.dim_topo
#
#     if incl_dn:
#         # add do nothing actions of subs with only 1 line:
#         count_lines = Counter(env.line_ex_to_subid) + Counter(env.line_or_to_subid)
#         one_line_subs = [sub for sub, n_lines in count_lines.items() if n_lines == 1]
#         for sub in one_line_subs:
#             # Default DN topology
#             topo = np.ones(env.sub_info[sub], dtype=int)
#             action = env.action_space(
#                 {"set_bus": {"substations_id": [(sub, topo)]}}
#             )
#             legal_actions.append(action)
#     else:
#         for index, row in dataframe.iterrows():
#             # Identify positive entries in the current row
#             positive_entries = row[row > 0].index.tolist()
#
#             # Check if the positive entries in the current row have corresponding empty columns in other rows
#             # in other words check if there exists another action next to this one (otherwise it is the DN action)
#             meets_condition = all(
#                 dataframe.loc[dataframe.index != index, positive_entries].eq(0).all(axis=1)
#             )
#
#             if not meets_condition:
#                 legal_actions.append(possible_substation_actions[index])
#
#     if opt_shunt:
#         legal_actions = get_optshunt_actions(env, legal_actions)
#     elif all_shunt:
#         legal_actions = get_optshunt_actions(env, legal_actions)
#     if rho_filter:
#         legal_actions = filter_actions(env, legal_actions)
#     return legal_actions
#
#
# def get_medha_dn_action_space(env: BaseEnv, opt_shunt=False, all_shunt=False, rho_filter: bool = False) -> list[BaseAction]:
#     """
#         Generate allowed actions based on the proposed action space by Subramanian et al. (2021).
#
#         EVDS: Added option
#             'opt_shunt'. If opt_shunt : Optimize the symmetry actions at the substations containing shunt.
#     """
#
#     # look at all substations (since all substations have more than one element)
#     legal_actions = []
#     possible_substation_actions = get_possible_topologies(
#         env, list(range(env.n_sub))
#     )
#
#     for action in possible_substation_actions:
#         topo_vect = action.set_bus
#         # Isolate this substation
#         non_zero_elements = [num for num in topo_vect if num != 0]
#
#         # Count occurrences of each non-zero element
#         element_counts = Counter(non_zero_elements)
#
#         # Check if there are at least two occurrences of each non-zero element
#         at_least_two_occurrences = all(count >= 2 for count in element_counts.values())
#
#         # get_possible_topologies already takes into account that a generator connected to no
#         # substation-substation lines does not work, so the constraint to check if one
#         # substation-substation line is connected to each busbar does not need to be tested
#         if at_least_two_occurrences:
#             legal_actions.append(action)
#
#     if opt_shunt:
#         legal_actions = get_optshunt_actions(env, legal_actions)
#     elif all_shunt:
#         legal_actions = get_allshunt_actions(env, legal_actions)
#
#     # add do nothing actions of subs with only 1 line:
#     count_lines = Counter(env.line_ex_to_subid) + Counter(env.line_or_to_subid)
#     one_line_subs = [sub for sub, n_lines in count_lines.items() if n_lines == 1]
#     for sub in one_line_subs:
#         # Default DN topology
#         topo = np.ones(env.sub_info[sub], dtype=int)
#         action = env.action_space(
#             {"set_bus": {"substations_id": [(sub, topo)]}}
#         )
#         legal_actions.append(action)
#
#     return legal_actions


def get_optshunt_actions(env: BaseEnv, actions: list[BaseAction]) -> list[BaseAction]:
    """
    This function checks for all actions related to a substation with shunt if the reversed action is better
    If this is the case the action is replaced by the reversed action

    Parameters
    ----------
    env: Grid2op Environment
    actions: List of grid2op actions.

    Returns
    -------
    actions: List of grid2op actions, similar to the old list, but  where some actions have been reversed
    """
    print("\nUse best actions for subs with shunt")
    env_rev = grid2op.make(env.env_name)
    count = 0
    for idx, act in enumerate(tqdm(actions)):
        lines_impact, subs_impact = act.get_topological_impact()
        if subs_impact[env.shunt_to_subid].any():
            sub_act = int(np.arange(env.n_sub)[subs_impact])
            topo_act = act.sub_set_bus[act.sub_set_bus > 0]
            # print(f'Substation {sub_act}, Topo {topo_act} ')
            # compute reversed action:
            rev_topo = np.where(topo_act == 1, 2, 1)
            act_rev = env.action_space(
                {"set_bus": {"substations_id": [(sub_act, rev_topo)]}}
            )
            # test n times and save best result.
            n = 20
            rhos_normal = np.zeros(n)
            rhos_rev = np.zeros(n)
            for i in range(n):
                # print("Chronic id of env: ", env.chronics_handler.get_name())
                # print("Chronic id of env_rev: ", env_rev.chronics_handler.get_name())
                obs = env.reset()
                obs_rev = env_rev.reset()
                # try action normal
                obs, reward, done, info = env.step(act)
                # try action reversed
                obs_rev, reward_rev, done_rev, info_rev = env_rev.step(act_rev)
                rhos_normal[i] = obs.rho.max() if obs.rho.max() > 0 else 2
                rhos_rev[i] = obs_rev.rho.max() if obs_rev.rho.max() > 0 else 2
            # # print mean max rho values
            # print('max rho NORMAL: ', rhos_normal.mean())
            # # print('vec: ', rhos_normal)
            # print('max rho REVERSED: ', rhos_rev.mean())
            # # print('vec: ', rhos_rev)
            if rhos_normal.mean() > rhos_rev.mean():
                actions[idx] = act_rev
                count += 1
                # print(f'Action adjusted to reverse topo: {rev_topo}')
                # print(actions[idx])
            # else:
            #     # print('Action remains the same.')
            #     # print(actions[idx])
    print(f"\n{count}/{len(actions)} actions have been reversed.")
    return actions


def get_allshunt_actions(env: BaseEnv, actions: list[BaseAction]) -> list[BaseAction]:
    """
    Include also reversed action to action space for substations with shunt.
    Parameters
    ----------
    env: Grid2op Environment
    actions: List of grid2op actions.

    Returns
    -------
    actions: List of grid2op actions, similar to the old list, but  where actions have been added for substations
    with shunt.
    """
    print("\nUse all actions for subs with shunt.")
    new_actions = []
    for idx, act in enumerate(tqdm(actions, desc="Selecting all shunt actions")):
        lines_impact, subs_impact = act.get_topological_impact()
        if subs_impact[env.shunt_to_subid].any():
            sub_act = int(np.arange(env.n_sub)[subs_impact])
            topo_act = act.sub_set_bus[act.sub_set_bus > 0]
            print(f'Substation {sub_act}, Topo {topo_act} ')
            # compute reversed action:
            rev_topo = np.where(topo_act == 1, 2, 1)
            act_rev = env.action_space(
                {"set_bus": {"substations_id": [(sub_act, rev_topo)]}}
            )
            new_actions.append(act_rev)
    actions.extend(new_actions)
    print(f"Action space increased with {len(new_actions)} actions")
    return actions


def action_satisfies_rhomax(multi_envs, act, rho_max, nb_workers):
    # Test each action at least 16 times to get mean of max rhos
    n = int(np.ceil(16/nb_workers))
    max_rhos = np.zeros(n * nb_workers)
    for i in range(n):
        for j, env in enumerate(multi_envs.envs):
            # Make sure each env uses different chronic and all actions are tested on the same chronics
            env.set_id(j * 10 * (i+1) + j)
        obss = multi_envs.reset()
        # print("multi_envs chron after reset: ", [e.chronics_handler.get_name() for e in multi_envs.envs])
        # try action normal
        obss, rewards, dones, infos = multi_envs.step([act for _ in range(nb_workers)])
        max_rhos[i*nb_workers : i*nb_workers + nb_workers] = [obs.rho.max() if obs.rho.max() > 0 else 2 for obs in obss]
    return np.mean(max_rhos) < rho_max


def apply_rho_filter(env: BaseEnv, actions: list[BaseAction], rho_max: float, nb_workers: int) -> list[BaseAction]:
    """
        This function checks for all actions if the mean rho value is higher than rho_max.
        If this is the case this action will not be included in the new_action_list.

        Parameters
        ----------
        env: Grid2op Environment
        actions: List of grid2op actions.
        rho_max: Float representing the limit of accepted actions.
        nb_workers: number of workers used to eval the actions

        Returns
        -------
        actions: List of grid2op actions, similar to the old list, but  where some actions have been reversed
        """
    print(f"\nUse rho_max {rho_max} to filter action space")
    nb_workers = nb_workers
    envs = []
    for i in range(nb_workers):
        new_env = env.copy()
        envs.append(new_env)

    print(f"Creating a multiprocess environment with {nb_workers} workers...")
    multi_envs = MultiEnvMultiProcess(envs, np.ones(nb_workers))
    # multi_envs = MultiEnvMultiProcess([env], [nb_workers])
    # print("multi_envs chron: ", [e.chronics_handler.get_name() for e in multi_envs.envs])
    new_action_list = []
    for idx, act in enumerate(tqdm(actions, desc="Evaluating all actions")):
        if action_satisfies_rhomax(multi_envs, act, rho_max, nb_workers):
            new_action_list.append(act)
    print(f"{len(new_action_list)}/{len(actions)} actions are kept in the new action space. "
          f"\nPercentage: {len(new_action_list)/len(actions) * 100:.2f}%")
    return new_action_list

#
# def get_tennet_action_space(env: BaseEnv) -> list[BaseAction]:
#     """
#     Generate allowed actions based on the proposed action space by Subramanian et al. (2021).
#     """
#     changeable_substations = get_changeable_substations_tennet(env)
#
#     possible_substation_actions = get_possible_topologies(env, changeable_substations)
#
#     legal_actions = []
#
#     non_lines = np.concatenate(
#         (env.action_space.gen_pos_topo_vect, env.action_space.load_pos_topo_vect)
#     ).tolist()
#
#     # Create the DataFrame with defined columns
#     dataframe = pd.DataFrame(
#         columns=list(
#             range(len(possible_substation_actions[0].to_json()["_set_topo_vect"]))
#         )
#     )
#
#     for action in possible_substation_actions:
#         topo_vect = action.to_json()["_set_topo_vect"]
#
#         lines_topo_vect = np.delete(topo_vect, non_lines)
#
#         # Filter out non-zero elements
#         non_zero_lines = [num for num in lines_topo_vect if num != 0]
#
#         # Count occurrences of each non-zero element
#         element_counts = Counter(non_zero_lines)
#
#         # Check if there are at least two occurrences of each non-zero element
#         at_least_two_occurrences = all(count >= 2 for count in element_counts.values())
#         if at_least_two_occurrences:
#             dataframe.loc[len(dataframe.index)] = topo_vect
#         else:  # add dummy to keep index intact
#             dataframe.loc[len(dataframe.index)] = [0] * len(
#                 possible_substation_actions[0].to_json()["_set_topo_vect"]
#             )
#
#     for index, row in dataframe.iterrows():
#         # Identify positive entries in the current row
#         positive_entries = row[row > 0].index.tolist()
#
#         # Check if the positive entries in the current row have corresponding empty columns in other rows
#         if not all(
#             dataframe.loc[dataframe.index != index, positive_entries].eq(0).all(axis=1)
#         ):
#             legal_actions.append(possible_substation_actions[index])
#
#     return legal_actions


def save_to_json(
    possible_substation_actions: List[BaseAction], json_file_path: str
) -> None:
    """Saves list of actions to .json that can be used in training."""
    actions_to_json = [
        {
            "set_bus": {
                "loads_id": [
                    [int(elem_id), int(bus_id)]
                    for elem_id, bus_id in enumerate(action.load_set_bus)
                    if bus_id > 0
                ],
                "generators_id": [
                    [int(elem_id), int(bus_id)]
                    for elem_id, bus_id in enumerate(action.gen_set_bus)
                    if bus_id > 0
                ],
                "lines_or_id": [
                    [int(elem_id), int(bus_id)]
                    for elem_id, bus_id in enumerate(action.line_or_set_bus)
                    if bus_id > 0
                ],
                "lines_ex_id": [
                    [int(elem_id), int(bus_id)]
                    for elem_id, bus_id in enumerate(action.line_ex_set_bus)
                    if bus_id > 0
                ],
            }
        }
        for action in possible_substation_actions
    ]
    # Save to json
    with open(json_file_path, "wt", encoding="utf-8") as file:
        json.dump(actions_to_json, file)


# if __name__ == "__main__":
#     # envs = ["rte_case5_example", "rte_case14_realistic", "l2rpn_wcci_2022"]
#     envs = ["rte_case5_example", "rte_case14_realistic"]
#     for env_name in envs:
#         environment = grid2op.make(env_name, test=True)
#
#         file_path = f"/Users/barberademol/Documents/GitHub/mahrl_grid2op/experiments/action_spaces/{env_name}/asymmetry.json"
#         save_to_json(get_asymmetrical_action_space(environment), file_path)
#
#         file_path = f"/Users/barberademol/Documents/GitHub/mahrl_grid2op/experiments/action_spaces/{env_name}/medha.json"
#         save_to_json(get_medha_action_space(environment), file_path)
#
#         file_path = f"/Users/barberademol/Documents/GitHub/mahrl_grid2op/experiments/action_spaces/{env_name}/tennet.json"
#         save_to_json(get_tennet_action_space(environment), file_path)
