"""
Implements the codes to configure the three kinds of action spaces.
"""

import json
import os.path
from collections import Counter
from typing import List

import grid2op
import numpy as np
import pandas as pd
from grid2op.Action import BaseAction
from grid2op.Environment import BaseEnv

from mahrl.grid2op_env.utils import get_possible_topologies


def get_changeable_substations_tennet(env: BaseEnv) -> list[int]:
    """
    Find all substations that have more than four lines and can therefore be acted upon
    according to the proposed TenneT action space.
    """
    changeable_substations = []

    # for all substations
    nr_substations = len(env.sub_info)
    for sub in range(nr_substations):
        nr_elements = len(env.observation_space.get_obj_substations(substation_id=sub))
        nr_non_lines = sum(
            1
            for row in env.observation_space.get_obj_substations(substation_id=sub)
            if row[1] != -1 or row[2] != -1
        )
        nr_lines = nr_elements - nr_non_lines

        # append this substation if it has more than four lines
        if nr_lines >= 4:
            changeable_substations.append(sub)

    return changeable_substations


def get_asymmetrical_action_space(env: BaseEnv) -> list[BaseAction]:
    """
    This returns all actions as generated by get_possible_topologies().
    """
    legal_actions = []
    # all substations
    possible_substation_actions = get_possible_topologies(
        env, list(range(len(env.sub_info)))
    )

    # Create the DataFrame with defined columns
    dataframe = pd.DataFrame(
        columns=list(
            range(len(possible_substation_actions[0].to_json()["_set_topo_vect"]))
        )
    )

    for action in possible_substation_actions:
        topo_vect = action.to_json()["_set_topo_vect"]
        dataframe.loc[len(dataframe.index)] = topo_vect

    for index, row in dataframe.iterrows():
        # Identify positive entries in the current row
        positive_entries = row[row > 0].index.tolist()

        # Check if the positive entries in the current row have corresponding empty columns in other rows
        meets_condition = all(
            dataframe.loc[dataframe.index != index, positive_entries].eq(0).all(axis=1)
        )

        if not meets_condition:
            legal_actions.append(possible_substation_actions[index])

    return legal_actions


def get_medha_action_space(env: BaseEnv, opt_shunt: bool = False, all_shunt: bool = False) -> list[BaseAction]:
    """
    Generate allowed actions based on the proposed action space by Subramanian et al. (2021).
    """

    # look at all substations (since all substations have more than one element)
    possible_substation_actions = get_possible_topologies(
        env, list(range(env.n_sub))
    )

    legal_actions = []

    # Create the DataFrame with defined columns
    dataframe = pd.DataFrame(
        columns=list(
            range(len(possible_substation_actions[0].to_json()["_set_topo_vect"]))
        )
    )

    for action in possible_substation_actions:
        topo_vect = action.set_bus
        # Isolate this substation
        non_zero_elements = [num for num in topo_vect if num != 0]

        # Count occurrences of each non-zero element
        element_counts = Counter(non_zero_elements)

        # Check if there are at least two occurrences of each non-zero element
        at_least_two_occurrences = all(count >= 2 for count in element_counts.values())

        # get_possible_topologies already takes into account that a generator connected to no
        # substation-substation lines does not work, so the constraint to check if one
        # substation-substation line is connected to each busbar does not need to be tested
        if at_least_two_occurrences:
            dataframe.loc[len(dataframe.index)] = topo_vect
        else:  # add dummy to keep index intact
            dataframe.loc[len(dataframe.index)] = [0] * env.dim_topo

    for index, row in dataframe.iterrows():
        # Identify positive entries in the current row
        positive_entries = row[row > 0].index.tolist()

        # Check if the positive entries in the current row have corresponding empty columns in other rows
        # in other words check if there exists another action next to this one (otherwise it is the DN action)
        meets_condition = all(
            dataframe.loc[dataframe.index != index, positive_entries].eq(0).all(axis=1)
        )

        if not meets_condition:
            legal_actions.append(possible_substation_actions[index])

    if opt_shunt:
        legal_actions = get_optshunt_actions(env, legal_actions)
    elif all_shunt:
        legal_actions = get_optshunt_actions(env, legal_actions)
    return legal_actions


def get_medha_dn_action_space(env: BaseEnv, opt_shunt=False, all_shunt=False) -> list[BaseAction]:
    """
        Generate allowed actions based on the proposed action space by Subramanian et al. (2021).

        EVDS: Added option
            'opt_shunt'. If opt_shunt : Optimize the symmetry actions at the substations containing shunt.
    """

    # look at all substations (since all substations have more than one element)
    legal_actions = []
    possible_substation_actions = get_possible_topologies(
        env, list(range(env.n_sub))
    )

    for action in possible_substation_actions:
        topo_vect = action.set_bus
        # Isolate this substation
        non_zero_elements = [num for num in topo_vect if num != 0]

        # Count occurrences of each non-zero element
        element_counts = Counter(non_zero_elements)

        # Check if there are at least two occurrences of each non-zero element
        at_least_two_occurrences = all(count >= 2 for count in element_counts.values())

        # get_possible_topologies already takes into account that a generator connected to no
        # substation-substation lines does not work, so the constraint to check if one
        # substation-substation line is connected to each busbar does not need to be tested
        if at_least_two_occurrences:
            legal_actions.append(action)

    if opt_shunt:
        legal_actions = get_optshunt_actions(env, legal_actions)
    elif all_shunt:
        legal_actions = get_allshunt_actions(env, legal_actions)

    # add do nothing actions of subs with only 1 line:
    count_lines = Counter(env.line_ex_to_subid) + Counter(env.line_or_to_subid)
    one_line_subs = [sub for sub, n_lines in count_lines.items() if n_lines == 1]
    for sub in one_line_subs:
        # Default DN topology
        topo = np.ones(env.sub_info[sub], dtype=int)
        action = env.action_space(
            {"set_bus": {"substations_id": [(sub, topo)]}}
        )
        legal_actions.append(action)

    return legal_actions


def get_optshunt_actions(env: BaseEnv, actions: list[BaseAction]) -> list[BaseAction]:
    """
    This function checks for all actions related to a substation with shunt if the reversed action is better
    If this is the case the action is replaced by the reversed action

    Parameters
    ----------
    env: Grid2op Environment
    actions: List of grid2op actions.

    Returns
    -------
    actions: List of grid2op actions, similar to the old list, but  where some actions have been reversed
    """
    env_rev = grid2op.make(env.env_name)
    for idx, act in enumerate(actions):
        lines_impact, subs_impact = act.get_topological_impact()
        if subs_impact[env.shunt_to_subid].any():
            sub_act = int(np.arange(env.n_sub)[subs_impact])
            topo_act = act.sub_set_bus[act.sub_set_bus > 0]
            print(f'Substation {sub_act}, Topo {topo_act} ')
            # compute reversed action:
            rev_topo = np.where(topo_act == 1, 2, 1)
            act_rev = env.action_space(
                {"set_bus": {"substations_id": [(sub_act, rev_topo)]}}
            )
            # test n times and save best result.
            n = 10
            rhos_normal = np.zeros(n)
            rhos_rev = np.zeros(n)
            for i in range(n):
                # print("Chronic id of env: ", env.chronics_handler.get_name())
                # print("Chronic id of env_rev: ", env_rev.chronics_handler.get_name())
                obs = env.reset()
                obs_rev = env_rev.reset()
                # try action normal
                obs, reward, done, info = env.step(act)
                # try action reversed
                obs_rev, reward_rev, done_rev, info_rev = env_rev.step(act_rev)
                rhos_normal[i] = obs.rho.max() if obs.rho.max() > 0 else 2
                rhos_rev[i] = obs_rev.rho.max() if obs_rev.rho.max() > 0 else 2
            # print mean max rho values
            print('max rho NORMAL: ', rhos_normal.mean())
            print('vec: ', rhos_normal)
            print('max rho REVERSED: ', rhos_rev.mean())
            print('vec: ', rhos_rev)
            if rhos_normal.mean() > rhos_rev.mean():
                actions[idx] = act_rev
                print(f'Action adjusted to reverse topo: {rev_topo}')
                # print(actions[idx])
            else:
                print('Action remains the same.')
                # print(actions[idx])
    return actions


def get_allshunt_actions(env: BaseEnv, actions: list[BaseAction]) -> list[BaseAction]:
    """
    Include also reversed action to action space for substations with shunt.
    Parameters
    ----------
    env: Grid2op Environment
    actions: List of grid2op actions.

    Returns
    -------
    actions: List of grid2op actions, similar to the old list, but  where actions have been added for substations
    with shunt.
    """
    new_actions = []
    for idx, act in enumerate(actions):
        lines_impact, subs_impact = act.get_topological_impact()
        if subs_impact[env.shunt_to_subid].any():
            sub_act = int(np.arange(env.n_sub)[subs_impact])
            topo_act = act.sub_set_bus[act.sub_set_bus > 0]
            print(f'Substation {sub_act}, Topo {topo_act} ')
            # compute reversed action:
            rev_topo = np.where(topo_act == 1, 2, 1)
            act_rev = env.action_space(
                {"set_bus": {"substations_id": [(sub_act, rev_topo)]}}
            )
            new_actions.append(act_rev)
    actions.extend(new_actions)
    return actions


def get_tennet_action_space(env: BaseEnv) -> list[BaseAction]:
    """
    Generate allowed actions based on the proposed action space by Subramanian et al. (2021).
    """
    changeable_substations = get_changeable_substations_tennet(env)

    possible_substation_actions = get_possible_topologies(env, changeable_substations)

    legal_actions = []

    non_lines = np.concatenate(
        (env.action_space.gen_pos_topo_vect, env.action_space.load_pos_topo_vect)
    ).tolist()

    # Create the DataFrame with defined columns
    dataframe = pd.DataFrame(
        columns=list(
            range(len(possible_substation_actions[0].to_json()["_set_topo_vect"]))
        )
    )

    for action in possible_substation_actions:
        topo_vect = action.to_json()["_set_topo_vect"]

        lines_topo_vect = np.delete(topo_vect, non_lines)

        # Filter out non-zero elements
        non_zero_lines = [num for num in lines_topo_vect if num != 0]

        # Count occurrences of each non-zero element
        element_counts = Counter(non_zero_lines)

        # Check if there are at least two occurrences of each non-zero element
        at_least_two_occurrences = all(count >= 2 for count in element_counts.values())
        if at_least_two_occurrences:
            dataframe.loc[len(dataframe.index)] = topo_vect
        else:  # add dummy to keep index intact
            dataframe.loc[len(dataframe.index)] = [0] * len(
                possible_substation_actions[0].to_json()["_set_topo_vect"]
            )

    for index, row in dataframe.iterrows():
        # Identify positive entries in the current row
        positive_entries = row[row > 0].index.tolist()

        # Check if the positive entries in the current row have corresponding empty columns in other rows
        if not all(
            dataframe.loc[dataframe.index != index, positive_entries].eq(0).all(axis=1)
        ):
            legal_actions.append(possible_substation_actions[index])

    return legal_actions


def save_to_json(
    possible_substation_actions: List[BaseAction], json_file_path: str
) -> None:
    """Saves list of actions to .json that can be used in training."""
    actions_to_json = [
        {
            "set_bus": {
                "loads_id": [
                    [int(elem_id), int(bus_id)]
                    for elem_id, bus_id in enumerate(action.load_set_bus)
                    if bus_id > 0
                ],
                "generators_id": [
                    [int(elem_id), int(bus_id)]
                    for elem_id, bus_id in enumerate(action.gen_set_bus)
                    if bus_id > 0
                ],
                "lines_or_id": [
                    [int(elem_id), int(bus_id)]
                    for elem_id, bus_id in enumerate(action.line_or_set_bus)
                    if bus_id > 0
                ],
                "lines_ex_id": [
                    [int(elem_id), int(bus_id)]
                    for elem_id, bus_id in enumerate(action.line_ex_set_bus)
                    if bus_id > 0
                ],
            }
        }
        for action in possible_substation_actions
    ]
    # Save to json
    with open(json_file_path, "wt", encoding="utf-8") as file:
        json.dump(actions_to_json, file)


if __name__ == "__main__":
    # envs = ["rte_case5_example", "rte_case14_realistic", "l2rpn_wcci_2022"]
    envs = ["rte_case5_example", "rte_case14_realistic"]
    for env_name in envs:
        environment = grid2op.make(env_name, test=True)

        file_path = f"/Users/barberademol/Documents/GitHub/mahrl_grid2op/experiments/action_spaces/{env_name}/asymmetry.json"
        save_to_json(get_asymmetrical_action_space(environment), file_path)

        file_path = f"/Users/barberademol/Documents/GitHub/mahrl_grid2op/experiments/action_spaces/{env_name}/medha.json"
        save_to_json(get_medha_action_space(environment), file_path)

        file_path = f"/Users/barberademol/Documents/GitHub/mahrl_grid2op/experiments/action_spaces/{env_name}/tennet.json"
        save_to_json(get_tennet_action_space(environment), file_path)
